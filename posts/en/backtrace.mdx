---
title: "Understanding Backtracking in a Different Way with Images and Gradual Steps"
tag: Coding
createAt: 2023/2/11
---

Today, I worked on a backtracking algorithm problem. The problem is as follows:

![](https://cdn.jsdelivr.net/gh/filess/img1@main/2023/02/11/1676101161776-a208b8e6-40f2-4785-9e1c-4ec4d5a8fcfb.png)

> Given a collection of candidate numbers `candidates` and a target number `target`, find all unique combinations in `candidates` where the chosen numbers sum to `target`.
> Each number in `candidates` may only be used once in the combination.
> Note: The solution set must not contain duplicate combinations.

Thus, I decided to write an article based on this problem to discuss the backtracking algorithm.

First, let's look at the most basic framework of backtracking:

```python
class Solution:
    def combinationSum2():
        res = []

        def tranceback():
           for i in xxx:

        tranceback()
        return res
```

This code essentially traverses an array.

However, the problem we often encounter is the need to reuse a certain element (perhaps the result does not allow duplicates, but we still need to traverse it more than once). For example, the most basic exhaustive approach to summation:

![](https://cdn.jsdelivr.net/gh/filess/img18@main/2023/02/11/1676101255682-fa2aeb83-e33a-4703-997f-2314287d4bde.png)

Such methods are very inefficient, as they repeatedly match combinations, such as `[1, 2]` and `[2, 1]`.

> In fact, backtracking is also a form of enumeration, but we have greater optimization potential. The core idea of the backtracking algorithm is to continuously try and error; at each step of the search, if the current decision is found to be infeasible, we backtrack to the previous step and make a new decision.

So we hope to "remember" the parts that have already been matched.

We will continue to add content to the code above:

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int):
        res = []

        def tranceback(index, path, remain):

           for i in range(index, len(candidates)):

        tranceback(0, [], target)
        return res
```

The backtracking function accepts three parameters: the first is the pointer, the second is the combination, and the third is how far the current combination is from the target.

The loop inside the function starts from the pointer's position, avoiding repeated checks.

Each time we iterate, we check if the requirements are met.

```python
for i in range(index, len(candidates)):
    candi = candidates[i]

    # If the target is reached, no need to continue looping
    if candi == remain:
        res.append(path + [candi])
        return
    # Not enough, continue
    if candi < remain:
        # Continue reading
```

If it's not enough, we can continue looping from the pointer:

```python
for i in range(index, len(candidates)):
    candi = candidates[i]

    # If the target is reached, no need to continue looping
    if candi == remain:
        res.append(path + [candi])
        return
    # Not enough, continue
    if candi < remain:
        for i in range(i + 1, len(candidates)):
            remain -= candi
            # Repeat the above operation
```

![](https://cdn.jsdelivr.net/gh/filess/img9@main/2023/02/11/1676101246046-fc35411e-bfa1-425c-87aa-6bc688e94af1.png)

Every time we traverse a number, the logic executed is similar: check if `remain` is sufficient; if not, proceed...

So we might as well reuse the function itself, simply moving the pointer one position forward.

```python
if candi < remain:
    tranceback(i + 1, path + [candi], remain - candi)
```

Imagine: if the target is infinitely large, we would keep calling the function, and the pointer would keep moving forward.

The outer loop allows each node to have the right to become the "start of an infinite loop."

This is the core idea of backtracking: starting from each node, then traversing the other nodes.

This code can still be optimized. Because in some cases, it is completely unnecessary to continue the loop, such as:

- The target has been reached
- The number pointed to by the current pointer exceeds the remaining sum

So each time we backtrack, we can check this, which is called "pruning."

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []

        def tranceback(index, path, remain):

           for i in range(index, len(candidates)):
                candi = candidates[i]

                if candi == remain:
                    res.append(path + [candi])
                    return
                if candi < remain:
                    tranceback(i + 1, path + [candi], remain - candi)
                if candi > remain:
                    return

        tranceback(0, [], target)
        return res
```

This is the complete backtracking solution. However, we can still improve it.

First, if the given array is sorted in ascending order, we can get results faster. Because the density of answers is higher among smaller numbers.

Second, if we encounter the same number, we can skip it directly. Because the answers are not allowed to be duplicated.

![](https://cdn.jsdelivr.net/gh/filess/img12@main/2023/02/11/1676101269773-c0a9429a-6c57-46bf-9574-6b955ad24105.png)

The optimized code:

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        res = []

        def tranceback(index, path, remain):

           for i in range(index, len(candidates)):

                candi = candidates[i]
                # Skip duplicates
                if i > index and candidates[i - 1] == candidates[i]:
                    continue
                if candi == remain:
                    res.append(path + [candi])
                    return
                if candi < remain:
                    tranceback(i + 1, path + [candi], remain - candi)
                if candi > remain:
                    return

        tranceback(0, [], target)
        return res
```

## Practice: The Eight Queens Problem

The "Eight Queens Problem" is a classic backtracking algorithm problem that requires placing 8 queens on an 8x8 chessboard so that no two queens threaten each other, meaning no two queens can be in the same row, column, or diagonal.

In the following source code, `yield` can be understood as adding elements to the result array.

```python
# state is a one-dimensional array that records the x-coordinates of the queens in each row. For example, [1, 4, 6, 3, 0, 7, 5, 2]

def queens(num=8, state=()):
    for pos in range(num):
        # Pruning: if there is a conflict, do not loop, equivalent to the above return
        if not conflict(state, pos):
            # When reaching the second to last row, there is no need to nest further; return all possible coordinates (non-compliant x positions have been filtered out)
            if len(state) == num - 1:
                yield (pos,)
            else:
                # Use the current state as the starting point and call the function itself again.
                for result in queens(num, state + (pos,)):
                    yield (pos,) + result
```

The same classic pattern: using the state of each loop as a starting point to search the remaining parts.

Thank you for reading, and feel free to follow my [GitHub](https://github.com/rivertwilight) for more technical content.

